# 常見問題

### 關於在CSUOJ上運行的問題:

1. #### 多樣例測試

   1. 循環

      在CSUOJ上大部分的題目都會進行多樣例測試，這指的是你的輸入和輸出行為要循環不只一次，解決方案如下:

      ```c
      #include <stdio.h>
      int main(void)
      {
          //你需要設置在循環外的變量
          while(scanf(/*你的輸入格式及變量*/)!=EOF)
          {
              //你的主程序
          }
          return 0;
      }
      ```

      > scanf()函式會在每次執行時回傳它成功把多少對應的值給了變量，並在接受到EOF(文件結尾)時回傳-1，因此檢查scanf()!=-1的效果是一樣的，更詳細正確的內容可以參考如下:
      >
      > https://www.runoob.com/cprogramming/c-function-scanf.html

   2. 換行

      在CSUOJ 上，通常要求每個樣例輸出只占一行，若是不換行就會過不了，記得修改為循環的格式後，每次樣例輸出也要換個行。
      
      **如果不同條件下寫了不同的輸出語句的話(例如有兩個在不同條件下執行的scanf()，記得也都要換行。**

### C語法格式問題

1. #### switch 

   在使用switch函數時常見以下問題:

   1. ##### 省略case和其後常量之間的空格:

      ```c
      switch(n)
      {
      	case0:
              break;
          case1:
              break;
          dafault:
      }
      ```

      這樣寫的話，switch會直接執行default，記得一定要有空格:

      ```c
      switch(n)
      {
      	case 0:
              break;
          case 1:
              break;
          default:
      }
      ```

   2. ##### 忘記break:

      這也是switch比較容易被忘記的特性，不在case執行完後break的話，程序會接著執行之後case的內容(不管你寫的判斷條件為何)，以下舉例:

      ```c
      int n = 0;
      switch(n)
      {
          case 0:
             	n = 1;
          case 2:
              n = 2;
      }
      printf("%d",n);
      ```

      這個例子最後輸出的是2。

2. #### while循環

   1. 省略大括號

      省略大括號一時爽，之後你就不會爽了，省略大括號會讓你的while只循環其後;前的那一部分代碼，大部分時候這都不是你想要的行為，以下滿天星的代碼為例:

      ```c
      while(true)/*只會循環這個部分*/;
      	printf("*");//不會在循環內執行
      ```

      修改如下就會正確運行了:

      ```c
      while(true)
      {
      	printf("*");
      }
      ```

3. #### main內的return

   1. 放錯位置

      請參考以下案例:

      ```c
      int main(void)
      {
      	return 0;
          printf("test");
      }
      ```

      在這種情況下，"test"是不會被輸出的，主函數(就是main那個東東)會在你return之後立刻結束執行，通常這種錯誤會犯在同學把程序修改成用while(scanf()!=EOF)的格式後，不小心把return包進了while循環裡。

4. #### scanf 函數

   1. 忘記在參數變量前加&

      你不該犯這個錯誤。(字符串例外，不需要加)

      ```c
      scanf("%d",n);//棒棒糖
      ```

   2. 忘記逗號

      ```c
      scanf("%d"n);//棒棒糖?
      ```

5. #### printf 函數

   1. 加了&

      ```c
      printf("%d",&n);
      ```

   2. 拼寫錯誤

      ```c
      print("%d",n);
      ```


### C程序設計問題

1. #### 變量放錯位置/需要在每次循環重置的變量沒有重置

   這個問題通常發生在同學們將程序修改成while(scanf()!=EOF)的格式之後，提交太多次的話在排名上難免看起來不好看，記得上傳之前都先在本地端多測試幾組樣例，看看是否有正確的重置。

   以下為例:

   ```c
   #include <stdio.h>
   //輸出n!
   int main(void)
   {
       int n;
     	int sum = 1;
       scanf("%d",&n);
       for(int i=1;i=<n;i++)
       {
           sum*=i;
       }
       printf("%d",sum);
       return 0;
   }
   ```

   通常修改後會犯的錯誤:

   ```c
   #include <stdio.h>
   //輸出n!
   int main(void)
   {
       int n;
     	int sum = 1;
       while(scanf("%d",&n)!=EOF)
       {
           for(int i=1;i=<n;i++)
           {
               sum*=i;
           }
      		printf("%d",sum);
       }
       return 0;
   }
   ```

   通常這種時候，同學就會到群裡面問:

   > 為什麼第一次跑的時候是對的，之後都錯了?

   我們觀察一下這個程序的行為，會發現，在第一個while循環時，sum的確是我們想要的1，但當他進入下一次循環，sum已經是上一次的n!了，結果自然不會對。

   修改如下即可:

   ```c
   #include <stdio.h>
   //輸出n!
   int main(void)
   {
       int n;
       while(scanf("%d",&n)!=EOF)
       {
        	int sum = 1;
           for(int i=1;i=<n;i++)
           {
               sum*=i;
           }
      		printf("%d",sum);
       }
       return 0;
   }
   ```

2. #### 下標溢位/指針指向了沒有賦值的地址

   **假如你的輸出是-178650等等預期上不可能出現的值，或是亂碼的話，看這裡**

   這種問題容易發生在循環遍歷數組的時候，記得: 

   > 一個長度為2的數組，最後一位是1(因為是從0開始算的)。

   那麼，如果下標超出了最大值會發生甚麼事呢?

   操作數組下標等於是進行指針操作，輸入下標n等於是從數組的第一個地址往後位移n位，以下為例:

   ```c
   int a[2] = {0,1};
   printf("%d\n",a[1]);
   printf("%d",*(a+1));
   ```

   輸出會是:

   ```
   1
   1
   ```

   因此，當下標超過最後一位的時候，他就會指向更後面的一個地址，而那個地址保存了甚麼是未知的，如果對這個地址進行賦值的話，也會修改掉一個未知地址內的值(所以會發生甚麼很難預期)。
   因此，如果在循環中對數組進行遍歷的話，多注意循環會循環幾次，還有對數組使用的局部變量究竟是1,2,3,...,n還是0,1,2,...,n-1。

3. #### 接收到空格

   **gets函數會在接收到換行符之後立刻跳出，因此也要注意這個問題。**

   c=getchar()函數和scanf("%c",&c)的行為類似，會接收換行符這個字符並傳遞到c裏。這通常會導致一些不如預期的行為，以下程序為例:

   ```c
   //超級計算機
   #include<stdio.h>
   int main()
   {
   	int M1,M2,R1,R2,R3;
       char c;
       while(scanf("%d %d",&M1,&M2)!=EOF)
       {
       	R1=0,R2=0,R3=0;
   		int f;
   		do
   		{
   	    	f = scanf("%c",&c);
   	    	switch(c)
   			{
   				case 65:R1=M1;break;
   				case 66:R2=M2;break;
   				case 67:M1=R3;break;
   				case 68:M2=R3;break;
   				case 69:R3=R1+R2;break;
   				case 70:R3=R1-R2;break;
   			}
   		}while(f!=-1&&c!='\n');
   		printf("%d,%d\n",M1,M2);
   	}
   	return 0;
   }
   ```

   我做一個輸入:

   ```
   100 288
   ABECED
   ```

   預期的輸出會是:

   ```
   388 388
   ```

   實際上的輸出是:

   ```
   100 288
   ```

   (而且沒有等待你輸入指令)


      這其實就是底下的scanf("%c",&c)將'\n'給了c之後，在do循環的判斷中使得c!='\n'的判斷為假，便直接跳出循環執行了printf()。

      一個常見的辦法便是在進入迴圈之前，先把上一個輸入的換行符利用一個getchar()或是scanf("%c")接收掉，再進入do循環。

      底下是修改好的例子:

      ```c
      //超級計算機
      #include<stdio.h>
      int main()
      {
      	int M1,M2,R1,R2,R3;
          char c;
          while(scanf("%d %d",&M1,&M2)!=EOF)
          {
              scanf("%c");//接收掉換行
          	R1=0,R2=0,R3=0;
      		int f;
      		do
      		{
      	    	f = scanf("%c",&c);
      	    	switch(c)
      			{
      				case 65:R1=M1;break;
      				case 66:R2=M2;break;
      				case 67:M1=R3;break;
      				case 68:M2=R3;break;
      				case 69:R3=R1+R2;break;
      				case 70:R3=R1-R2;break;
      			}
      		}while(f!=-1&&c!='\n');
      		printf("%d,%d\n",M1,M2);
      	}
      	return 0;
      }
      ```
